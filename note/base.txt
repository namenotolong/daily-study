一.const与define
const 定义的是变量不是常量，只是这个变量的值不允许改变是常变量！带有类型。编译运行的时候起作用存在类型检查。
define 定义的是不带类型的常数，只进行简单的字符替换。在预编译的时候起作用，不存在类型检查。
两者区别：
(1) 编译器处理方式不同
#define 宏是在预处理阶段展开。
 const 常量是编译运行阶段使用。
(2) 类型和安全检查不同
 #define 宏没有类型，不做任何类型检查，仅仅是展开。
 const 常量有具体的类型，在编译阶段会执行类型检查。
(3) 存储方式不同
#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
const常量会在内存中分配(可以是堆中也可以是栈中)。
(4) const 可以节省空间，避免不必要的内存分配
(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
(6) 宏替换只作替换，不做计算，不做表达式求解;

二.存储类
auto、register、static、extern
1.auto,局部变量默认修饰，只能修饰局部变量
2.register,寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。
3.static,指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。
4.extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

三.指针
函数返回指针：
C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。
因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。
除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。

四.字符串
以null \0 结尾的char数组，sizeof比length大1

五.结构体、共同体
1.结构体
结构体内存大小对齐原则，结构体分配的内存空间按照成员变量中占用空间最大的来作为分配单位
结构体变量的首地址能够被其最宽基本类型成员的大小所整除。
结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小的整数倍
结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在成员末尾加上填充字节。

结构体内存分配原则
原则一：结构体中元素按照定义顺序存放到内存中，但并不是紧密排列。从结构体存储的首地址开始 ，每一个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始。
原则二： 在原则一的基础上，检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为它的整数倍。

2.共同体
共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

六.文件io
只有用 r+ 模式打开文件才能插入内容，w 或 w+ 模式都会清空掉原来文件的内容再来写，a 或 a+ 模式即总会在文件最尾添加内容，哪怕用 fseek() 移动了文件指针位置。
fopen函数可能执行失败，返回值是NULL，安全起见必须对返回值进行合法性判断
该函数有多种模式，其中r+和w+看似一样，都是读写其实还是有几点区别的；
      1.模式r+找不到文件不会自动新建，而w+会；
      2.模式r+打开文件后，不会清除文件原数据，若直接开始写入，只会从起始位置开始进行覆盖，而w+会直接清零后，再开始读写；
模式的合法性说明：不能用大写，只能是小写，且rb+和r+b都是合法的，但br+和+rb等都是非法的，w和a也是一样的处理；
模式w的自动新建文件是有条件的，只有对应的路径存在(即文件所在的文件夹存在)，文件不存在才会新建，否则是不会新建的，返回NULL

七.预处理器
include < > 引用的是编译器的类库路径里面的头文件。
#include " " 引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。




为什么数组传递参数sizeOf / perSize 一直2？
因为传递过去的只是指针变量占有的空间8个字节。系统并不知道指针所占用的实际内存大小