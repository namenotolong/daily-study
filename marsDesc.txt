mars

日志：
clientWorker中每5秒发送一次心跳，每2s更新一次所有任务的日志
显示调用AppolloUtils.update**Log

分布式锁DistributeLocker：
每一分钟检查master，如果master超过两分钟没有update则被其他worker抢占master，进行master初始化，最后和master进行connect

master：

1.MasterServer：使用netty构造一个服务端，用于接受请求，使用masterHandler处理器，使用Protobuf编解码

2.MasterContext：初始化master入口，master执行上下文，用于获取各种属性工具
属性：spring应用上下文、Quartz调度器scheduler、时间分发器dispatcher、master处理器masterHandler、服务端masterServer、master处理中心master
公用线程池threadPool、公用定时调度线程池schedulePool，repeatPool、按照debug，manual，schedule以及优先级的存储任务的队列（任务ID queue，ID和job map）

3.masterHandler：
内部类：ChannelResponse、发送请求时的返回data，包含channel、WebResponse
内部接口：ResponseListener，发送请求时回调触发
属性：对应master收到的事件处理
workers:Map<Channel, MasterWorkerHolder>.用于存储链接的worker信息
MasterBeHeartBeat: 接受心跳请求，更新workers的信息
MasterBeUpdate：更新job，使用dispatcher分发器发出一个JobMaintenanceEvent的更新job事件
MasterBeWebCancel：用于取消job，先看队列里面是否在等待运行（移除队列）、再看是否在master（执行取消命令，移除running队列）、worker机器上运行（发出worker取消任务消息，移除running队列）
MasterBeWebExecute：用于执行debug、schedule、manual任务（将任务放置在master对应的队列里面，等待分发）
MasterBeWebDebug：debug任务，目前未使用该对象来debug任务，使用的是MasterBeWebExecute
MasterBeWebModify：修改调度任务执行状态，使用dispatcher分发器发出一个JobSuccessEvent的更新job事件
MasterBeWebDelDir：删除过期工作目录，分为dubug、schedule、manual三种类型
MasterBeWebUpdateTreeCache：更新开发中心树，貌似并没有用
方法：处理worker发出的消息：messageReceived，四种类型消息，request、web_request、response、web_response


4.master类

初始化bean、给分发器注入监听器、将所有schedule表的任务转化为controller加入分发器
处理补数据任务:
广播一个初始化事件：针对预发环境不调度这是cancel为true，取消分发的下一步操作，但是所有监听器还是会受到该事件
初始化补数据任务，对等待的补数据任务开始运行
计算服务启动处理调度周期没有更新完的记录
每一分钟检测schedule_version中延迟调度状态并且开始调度时间到了的调度任务进行调度（每次300个）

每1s扫描一次等待执行队列的任务，选择合适的机器，对worker发出运行消息，开始运行
每1s对等待队列任务检测success文件，检测成功后将任务变成功状态，将任务加入待执行队列
每30s扫描worker的channel看是否连接正常，否则主动断开
10分一次的处理任务超时
2s一次的更新日志
30分一次的检测任务产出时间
将等待队列、等待执行队列加入到master的两个队列里面，白天和晚上的，注意加入的顺序，与初始化了的两个任务状态队列配合使用（高低优先级）

5.dispatcher：事件分发器

使用两个线程池一个用来处理调度事件，一个用来处理失败任务和补数据事件；另外用一个定时任务动态调整前面两个线程池的容量以及打印任务执行情况

处理事件采用观察者模式，发送一个事件给处理器，让所有监听者进行识别事件处理，这儿的监听者是在master初始化时加入

分发流程：

1.任务失败事件单独处理，对所有的影响任务ID单独创建一个对应的mvcEvent处理，让给该任务的controller执行，广播给监听器前置检测消息
其他事件处理：先广播给监听器前置检测消息，返回true执行下一步（预发由于配置了取消调度监听会返回false），对所有任务对应的controller执行handleEvent方法(提交到线程池执行)，补数据和调度的使用不同的线程池，方便查看任务运行情况。最后广播给所有后置监听者

2.广播事件(使用了观察者模式)
一个事件让所有监听者处理，监听者在master初始化时注入，包括
StopScheduleJobListener用于在初始化让分发器一直取消事件的下一步执行
AddJobListener处理JobMaintenanceEvent
JobFailListener处理JobFailedEvent
DebugListener处理DebugFailEvent、DebugSuccessEvent
JobSuccessListener处理JobSuccessEvent

3.Controller处理，使用JobController实现类执行
广播结束后让所有controller继续处理该事件（任务失败、补数据事件除外且cancel为false）
除了任务失败或者补数据任务所有controller都是单独开线程执行：如果执行时间超过了配置时间将会打印警告日志
执行handleEvent()方法，用来处理对应事件，具体事件：
JobSuccessEvent：只有上游任务列表中包含该事件任务ID 的依赖调度任务才需处理
补数据成功的消息通知，处理下游任务执行与否
JobFailedEvent：在dispatcher已经处理
ScheduleTriggerEvent：定时任务起调事件，只有对应的任务controller才能处理
JobMaintenanceEvent：只有对应的任务controller才能处理（只有新增任务已存在时处理）
初始化：兼容历史数据，将正在running、wait状态的任务矫正、重跑任务，如果在跑的要kill，定时任务使用cron注册一个schedule，

4.schedule如何调度任务？
TimerJob实现org.quartz.Job，调度时间使用分发器分发ScheduleTriggerEvent事件


Job 的run方法：针对不同实现




clientWoker:
每隔5s发送一次心跳：执行命令读取自身的menInfo、loadInfo发送给master
每隔2s更新所有任务的日志信息