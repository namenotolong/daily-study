# 对象是否可以回收
## 引用计数法
每个对象添加一个引用计数，为0标识对象没有被使用，但是会出现相互引用的case，基本所有jvm没有使用该算法
## 可达性分析
从“GC Roots”的对象作为起始，节点所走过的引用链之外的对象判定为对象不可用  
GC Roots：方法区常量引用对象、类静态属性引用对象、虚拟机栈引用对象、本地方法栈引用对象  
再判断：标记对象不可用后不是立刻回收，会检测对象是或否重写finalize()方法或者该方法已被虚拟机调度用，若是则立即回收，否则加入F-Queue队列，进行第二次标记（虚拟机建立一个低优先级线程执行该方法，但是并保证一定会运行结束，因为如果该方法出现死循环等极端情况会导致内存回收系统崩溃。如果该方法执行结束还是没有加入到引用链则进行回收）
# 常量回收
如果一个常量没有被任务对象引用则会被回收
# 类回收
1. 类所有实例都被回收
2. 加载该类的ClassLoader被回收
3. 该类的java.lang.Class对象没有被引用  
满足以上三个条件可以进行回收（类回收是删除JVM中该类相关的所有信息）
# 回收算法
## 标记清除算法
1. 标记、清除效率都不高
2. 造成内存碎片，无法分配大对象，频繁触发GC
## 复制算法
1. 效率高，没有内存碎片
2. 只能使用一半的内存，适用于新生代，不适用于老年代
## 标记整理算法
1. 标记阶段和标记清除算法一致，整理是让内存紧凑在一起，解决了内存碎片、内存浪费问题
2. 适用于老年代
## 分代收集算法
1. 先用商业虚拟机基本采用该方法
2. 将java堆分成年轻代、老年代，根据各个年代的特点使用不同的回收算法
# 收集器
## Serial收集器 
1. 历史最悠久、单线程（回收期间会STW），单CPU广泛使用
2. 新生代复制算法，老年代（需要其他收集器配合）标记整理算法
## ParNew收集器
1. Serial的多线程版本，但是回收期间也会STW
2. 除了Serial收集器，只有它能与CMS收集器（真正意义上的并发收集器）配合工作
## Parallel Scavenge收集器
1. 似于ParNew 收集器。它是jdk1.8的默认是默认收集器。
 https://blog.csdn.net/cy973071263/article/details/104163611
